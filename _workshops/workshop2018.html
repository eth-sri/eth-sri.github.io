---
title: Workshop on Dependable and Secure Software Systems
ref: workshop2018
redirect_from: workshop2018.php
bgimage: /assets/images/eth-zurich-workshop.jpg
image: /assets/images/workshop2018.png
dates: Oct 19-20, 2018
place: ETH Zürich
venue: Alumni Pavillon, Rämlmistrasse 101
---



{% comment %}
		<li><a href="#workshop">Home</a></li>
		<li><a href="#schedule">Schedule</a></li>
		<li><a href="#registration">Registration</a></li>
		<li><a href="#travel">Travel</a></li>
		<li><a href="#accomodation">Accomodation</a></li>
<script type='text/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.js'></script>
<script src="https://www.sri.inf.ethz.ch/js/jquery.scrollTo-1.4.3.1-min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/tooltipsy.min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/global.js" type="text/javascript"></script>
{%endcomment%}

<h2>Workshop Information</h2>
Ensuring that our programs behave correctly and reliably is a fundamental challenge facing computing today. Recent years have seen an explosion of a diverse set of new techniques for ensuring program correctness ranging from verification and synthesis approaches to runtime systems to quantitative reasoning. The aim of the workshop is to provide insight into the latest research advances in the area. In a period of two days, the workshop will host a number of invited speakers who will present research talks related to software reliability and correctness.

<h2>Organizers</h2>
<p>
<a href="http://www.pm.inf.ethz.ch/people/personal/pmueller-pers.html">Peter M&uumlller (ETH Z&uumlrich) </a>, <a href="{{ "/people/martin" | relative_url }}">Martin Vechev (ETH Z&uumlrich) </a>, <a href="http://web.cs.ucdavis.edu/~su/">Zhendong Su (ETH Z&uumlrich)</a>
</br>
This is the sixth time the workshop is being held (formerly Workshop on Software Correctness and Reliability).  Materials from the
<a href="{{ "/workshop2017" | relative_url }}">2017</a>,
<a href="{{ "/workshop2016" | relative_url }}">2016</a>,
<a href="{{ "/workshop2015" | relative_url }}">2015</a>,
<a href="{{ "/workshop2014" | relative_url }}">2014</a> and
<a href="{{ "/workshop2013" | relative_url }}">2013</a> workshops are also available.
</p>


<h2 id="schedule">Schedule</h2>
<h3>October 19 (Friday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=17%>Time</th>
<th width="16%">Speaker</th>
<th width="22%">Institution</th>
<th width=33%>Talk Title & Abstract</th>
<th width=8%>Slides</th>
<th width=4%>Video</th>


<tr>
	<td>9:00  - 9:15</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Introduction of participants. Workshop objectives.">Opening Remarks </div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>9:15 - 10:00</td>
	<td><a href="http://www.cs.umd.edu/~mwh/"><div class="talk" style="font-weight: normal;" data-tooltip="Michael W. Hicks is a Professor in the Computer Science department and recently completed a three-year term as Chair of ACM SIGPLAN, the Special Interest Group in Programming Languages. His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and explored technologies to shorten patch application times by allowing software upgrades without downtime. Recently he has been looking at synergies between cryptography and programming languages, as well techniques involving random testing and probabilistic reasoning. He also led the development of a new security-oriented programming contest, 'build-it, break-it, fix-it,' which has been offered to the public and to students of his Coursera class on Software Security. He blogs at http://www.pl-enthusiast.net/.">Michael Hicks</div></a></td>
	<td>Maryland, USA</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Numeric static analysis for Java has a broad range of potentially useful applications, including array bounds checking and resource usage estimation. However, designing a scalable numeric static analysis for real-world Java programs presents a multitude of design choices, each of which may interact with others. For example, an analysis could handle method calls via either a top-down or bottom-up interprocedural analysis. Moreover, this choice could interact with how we choose to represent aliasing in the heap and/or whether we use a relational numeric domain, e.g., convex polyhedra. In this paper, we present a family of abstract interpretation-based numeric static analyses for Java and systematically evaluate the impact of 162 analysis configurations on the DaCapo benchmark suite. Our experiment considered the precision and performance of the analyses for discharging array bounds checks. We found that top-down analysis is generally a better choice than bottom-up analysis, and that using access paths to describe heap objects is better than using summary objects corresponding to points-to analysis locations. Moreover, these two choices are the most significant, while choices about the numeric domain, representation of abstract objects, and context-sensitivity make much less difference to the precision/performance tradeoff.">Evaluating Design Tradeoffs in Numeric Static Analysis for Java</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>10:00 - 10:45</td>
	<td><a href="http://web.cs.ucla.edu/~harryxu/">Harry Xu</a></td>
	<td>UCLA, USA</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Static program analysis has been widely used in academia and industry to find bugs, security vulnerabilities, and optimization opportunities.  Despite significant progresses on algorithmic design, existing analysis techniques often cannot scale to large codebases, are difficult to implement/understand by regular developers, and are incapable of analyzing programs involving multiple languages. I will talk about a project that revisits these problems from a data-driven perspective and develops novel system solutions that can make static analyses easy-to-implement, support large codebases, and support programs written in multiple languages. In particular, I will focus on two graph systems we have developed: Graspan and Grapple. Graspan is a disk-based parallel graph system that supports efficient and scalable CFL-reachability computation over very large program graphs, while Grapple is a graph engine designed to support efficient and scalable context-sensitive and path-sensitive static analysis. We have used these tools to analyze a variety of large-scale software systems, such as the Linux kernel (C), the PostgreSQL database (C), and Apache Hadoop (Java), and found numerous bugs in recent versions of these systems. Our results also demonstrate that the analysis implementations based on our graph engines have an order of magnitude fewer lines of code than their traditional counterparts and yet are much more efficient.">Systemized Program Analysis - A Big Data Perspective on Scalable, Easy-to-Implement, and Multilingual Static Analysis</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>10:45 - 11:15</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>11:15 - 12:00</td>
	<td><a href="https://www.microsoft.com/en-us/research/people/nswamy/">Nikhil Swamy</a></td>
	<td>Microsoft Research</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="For program verification at scale, proof automation is just as important as user-control of automation heuristics and proof stability. Whereas SMT-based program verifiers offer good automation on various classes of problems, they provide users with little control and large proofs can be unpredictable. Further, proofs in logics outside SMT-automatable theories are difficult or impossible. On the other hand, scripting proofs with tactics has been a tradition in interactive theorem proving for decades. However, building application-specific tactics can require a significant effort. Meta-F* is a new metaprogramming framework embedded within the F* proof assistant. It promotes a combination of SMT- and tactic-based proofs for dependently typed, higher order, effectful programs. Drawing on experience with Project Everest, an ongoing effort to verify a secure communication stack in F*, we show that scripting only those parts of proofs that SMT solvers handle poorly improves overall proof robustness and automation at a relatively low cost for the tactic programmer.">Meta-F*: Proof Automation with SMT, Tactics, and Metaprograms</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>12:00 - 13:30</td>
	<td></td>
	<td colspan=2>Lunch</td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>13:30 - 14:15</td>
	<td><a href="https://www.cs.purdue.edu/homes/suresh/"><div class="talk" style="font-weight: normal;" data-tooltip="Suresh Jagannathan is the Samuel D. Conte Professor of Computer Science at Purdue University.  His research interests are in programming languages generally, with specific focus on functional programming, program verification and analysis, and concurrent and distributed systems.  From 2013 - 2016, he served as a program manager manager in the Information Innovation Office at DARPA, where he conceived and led programs in probabilistic reasoning and machine learning, software systems, and adaptive computing.  He has also been a visiting faculty at Cambridge University, where he spent a sabbatical year in 2010; and, prior to joining Purdue, was a senior research scientist at the NEC Research Institute in Princeton, N.J. He received his PhD from MIT.">Suresh Jagannathan</div></a></td>
	<td>Purdue, USA</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Specifications given in the form of logical assertions, loop invariants, or pre- and post-conditions, play a critical role in any verification task.  Because poor specifications are more likely than not to lead to verification failure, developers must take great care to ensure that provided specifications are both precise (i.e., exclude any unwanted behaviours), and general (i.e., include all desirable ones).  Generating useful specifications manually is challenging however, often proportional to the complexity of the code being specified; on the other hand, existing automated inference techniques can oftentimes be too brittle, limiting their utility.  As a result, the current state-of-affairs has hampered wider adoption and integration of verification tools and techniques.

	In this talk, we present a recent line of work on the automated synthesis and discovery of specifications that overcome many of the deficiencies found in existing methods. Our main contribution is a formulation of the problem as a data-driven one that leverages off-the-shelf machine learning algorithms and theorem provers to generate useful candidate specifications that can be used as part of an automated verification pipeline.  We highlight several instantiations of this approach, including inference of sophisticated shape specifications for functional data structure verification, and predicate inference in CHC (Constrained Horn Clause) systems to enable verification of numeric programs.

	Experimental results indicate that our techniques are both efficient and effective, capable of automatically producing useful and verifiable specifications over a range of complex real-world programs, going well beyond the capabilities of existing solutions.">Learning to Specify</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>14:15 - 15:00</td>
	<td><a href="http://people.csail.mit.edu/sachour/"><div class="talk" style="font-weight: normal;" data-tooltip="Sara Achour is a PhD candidate at the Computer Science and Artificial Intelligence Laboratory at Massachusetts Institute of Technology (CSAIL MIT) and a NSF Fellowship recipient. Her current research focuses on compilation techniques for reconfigurable analog devices. Her broader research interests focus on developing automated techniques for nontraditional computational platforms and devices.">Sara Achour</div></a></td>
	<td>MIT, USA</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Programmable analog devices are a powerful new computing substrate that are especially appropriate for performing computationally intensive simulations of dynamical systems. Until recently, the de-facto standard for programming these devices required hardware specialists to manually program the analog device to model the dynamical system of interest. In this talk, I will present Arco, a compiler that automatically configures analog devices to perform dynamical system simulation, and Jaunt, a compilation technique that that scales dynamical system parameters to change the speed of the simulation and render the resulting simulation physically realizable given the operating constraints of the analog hardware platform.  These techniques capture the domain knowledge required to fully exploit the capabilities of reconfigurable analog devices, eliminating a key obstacle to the widespread adoption of these devices.">Compiling Dynamical Systems for Efficient Simulation on Reconfigurable Analog Computers</div></td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>15:00 - 15:30</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>15:30 - 15:55</td>
	<td><a href="http://web.cs.ucdavis.edu/~su/"><div class="talk" style="font-weight: normal;" data-tooltip="Zhendong Su is a Professor in Computer Science at ETH Zurich. Previously, he was a Professor in Computer Science and a Chancellor's Fellow at UC Davis. He received his PhD in Computer Science from UC Berkeley.  His research spans programming languages and compilers, software engineering, computer security, deep learning and education technologies.  His work was recognized by an ACM SIGSOFT Impact Paper Award, a Google Scholar Classic Paper (2017) Award, multiple best/distinguished paper awards at top venues, an ACM CACM Research Highlight, an NSF CAREER Award, a UC Davis Outstanding Faculty Award, and multiple industrial faculty awards.  He serves on the steering committees of ISSTA and ESEC/FSE, served as an Associate Editor for ACM TOSEM, co-chaired SAS 2009, program chaired ISSTA 2012, and program co-chaired SIGSOFT FSE 2016.">Zhendong Su</div></a></td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="This talk introduces mathematical execution (ME), a general approach for testing numerical software. ME captures a desired testing objective via a representing function and transforms automated testing to the minimization of the representing function (which is solved via mathematical optimization).  Critically, ME systematically directs input space exploration by only executing the representing function to avoid the intractable static/symbolic reasoning of numerical code.  To demonstrate ME's power and promise, this talk describes ME-based algorithms for solving floating-point constraints and coverage-based testing of numerical code that lead to drastically improved results over the state-of-the-art.">	Numerical Program Analysis via Mathematical Execution</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>15:55 - 16:20</td>
	<td><a href="{{ "/people/martin" | relative_url }}">Martin Vechev</a></td>
	<td>ETH Z&uumlrich</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>16:20 - 16:45</td>
	<td><a href="http://www.pm.inf.ethz.ch/people/personal/pmueller-pers.html">Peter M&uumlller</a></td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" style="color: #0079AF;" title="CTL is a temporal logic commonly used to express program properties. Most of the existing approaches for proving CTL properties only support certain classes of programs, limit their scope to a subset of CTL, or do not directly support certain existential CTL formulas. This talk presents an abstract interpretation framework for proving CTL properties that does not suffer from these limitations. Our approach automatically infers sufficient preconditions, and thus provides useful information even when a program satisfies a property only for some inputs. We systematically derive a program semantics that precisely captures CTL properties by abstraction of the operational trace semantics of a program. We then leverage existing abstract domains based on piecewise-defined functions to derive decidable abstractions that are suitable for static program analysis.">Abstract Interpretation of CTL Properties</div></td>
	<td></td>
	<td></td>
</tr>
</table>

<h3>October 20 (Saturday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=17%>Time</th>
<th width="16%">Speaker</th>
<th width="22%">Institution</th>
<th width=33%>Talk Title & Abstract</th>
<th width=8%>Slides</th>
<th width=4%>Video</th>

<tr>
	<td>9:00  - 9:15</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Introduction to second day.">Opening Remarks </div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>9:15 - 10:00</td>
	<td><a href="https://www.st.cs.uni-saarland.de/zeller/"><div class="talk" style="font-weight: normal;" data-tooltip="Andreas Zeller is Faculty at the Center for IT-Security, Privacy, and Accountability (CISPA), and professor for Software Engineering at Saarland University, both in Saarbrücken, Germany. In 2010, Zeller was inducted as Fellow of the ACM for his contributions to automated debugging and mining software archives, for which he also obtained the ACM SIGSOFT Outstanding Research Award in 2018.  His current work focuses on specification mining and test case generation, funded by grants from DFG and the European Research Council (ERC).">Andreas Zeller</div></a></td>
	<td>Saarland, Germany</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Model-based testing techniques allow for a thorough exploration of the program behavior, but require a model in the first place. Model inference techniques, on the other hand, promise to extract suitable models from program executions, but require these very executions in the first place. Is there a way out of this chicken-and-egg problem? In this talk, I suggest to conduct both testing and inference at the system interface, which allows a clear distinction between valid and invalid inputs, and effectively allows to both test and infer models at the same time. Given only a program without any sample inputs, our AUTOGRAM prototype uses parser-directed test generation to infer a context-free grammar that models the program input; this grammar can be immediately used to synthesize millions of valid inputs.">Advances in Grammar Mining and Testing</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
<td>10:00 - 10:45</td>
<td><a href="https://www.cs.purdue.edu/homes/xyzhang/"><div class="talk" style="font-weight: normal;" data-tooltip="Dr. Xiangyu Zhang is a Professor from the Computer Science Department of Purdue University and a University Scholar. His research focuses on program analysis, security and recently AI model debugging and security. Dr. Zhang has received a number of prestigious awards such as ACM SIGPLAN Distinguished Dissertation Award,  Distinguished Paper and Best Paper Awards on FSE, CCS, USENIX Security, NDSS, and ASE. He has co-supervised a PhD dissertation that received the 2017 ACM SIGACT Distinguished Dissertation Award. Dr. Zhang is currently an Associate Editor for the IEEE Transactions on Software Engineering (TSE).">Xiangyu Zhang</div></a></td>
<td>Purdue, USA</td>
<td><div class="talk" style="color: #0079AF;" data-tooltip="Artificial intelligence and machine learning models are becoming an integral part of modern computing systems. Just like software inevitably has bugs, models have bugs too, leading to poor classification/ prediction accuracy or security vulnerabilities. In this talk, I will present our recent work on AI model debugging and adversarial sample attack detection. Inspired by software debugging, we propose a model debugging technique that works by first conducting model state differential analysis to identify the internal features of the model that are responsible for model bugs and then performing training input selection that is similar to program input selection in regression testing. Our results show that the technique can improve model accuracy by 10-15% with very little additional training time, even for off-the-shelf well-trained models. Adversarial sample attacks perturb benign inputs to induce DNN misbehaviors. We argue that adversarial sample attacks are deeply entangled with interpretability of DNN models: while classification results on benign inputs can be reasoned based on the human perceptible features/attributes, results on adversarial samples can hardly be explained. I will talk about an adversarial sample detection technique for face recognition models, based on interpretability. It can achieve 94% detection accuracy for 7 different kinds of attacks with 9.91% false positives on benign inputs.">Analyzing AI Model Internals for Debugging and Adversarial Sample Attack Detection</div></td>
<td></td>
<td></td>
</tr>

<tr>
	<td>10:45 - 11:15</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>11:15 - 12:00</td>
	<td><a href="https://www.microsoft.com/en-us/research/people/mabrocks/"><div class="talk" style="font-weight: normal;" data-tooltip="Marc Brockschmidt is a Senior Researcher in the Machine Intelligence group at Microsoft Research Cambridge (UK). He obtained his PhD studying formal methods that can automatically prove termination of Java programs. Surprisingly, that did work substantially less well than manually proving termination of Java programs. He thus moved on to study how computers can learn the skills that make humans better at programming than machines.">Marc Brockschmidt</div></a></td>
	<td>Microsoft Research</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Deep Learning has been the crucial step forward in perceptual tasks such as the understanding of images, speech and natural language. So far, it has had less impact on the practice of Software Engineering, where it is competing with a wide variety of mature, existing methods based on logic and deduction. I will discuss how these two worlds can be combined, as well as present first results that can show the way towards practical tools. Finally, I will report on user experience problems arising from the use of Deep Learning in Software Engineering tools.">Understanding and Generating Source Code with Deep Learning</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>12:00 - 13:30</td>
	<td></td>
	<td colspan=2>Lunch</td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>13:30 - 14:15</td>
	<td><a href="https://yanniss.github.io/"><div class="talk" style="font-weight: normal;" data-tooltip="Yannis Smaragdakis (http://smaragd.org) is a Professor at the University of Athens. Prior to that he had a 10+ year faculty career in the US, most recently as an Associate Professor at the University of Massachusetts, Amherst. His interests include program analysis and testing (especially pointer analysis, static-dynamic analysis combinations, and invariant inference); declarative and extensible languages (especially program generators, generics/templates, and applications of the Datalog language); and languages and tools for systems (especially multi-threading, parallel and distributed computing, and program locality). Large parts of his FC++ project have been integrated into the Boost C++ libraries, and he continues to maintain strong ties to industrial development and open-source projects. His latest work includes the Doop framework for the analysis of Java bytecode, as well as other related projects for program analysis algorithms expressed declaratively, in the Datalog language. Smaragdakis has served on the SIGPLAN Executive Committee and was the Program Chair of OOPSLA'16. He is a recipient of an NSF Career award, ERC Consolidator and Proof-of-Concept grants, and best/distinguished paper or artifact awards at ECOOP'18, OOPSLA'15, ISSTA'12, ASE'07, ISSTA'06, GPCE'04, USENIX'99.">Yannis Smaragdakis</div></a></td>
	<td>Athens, Greece</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="The talk will discuss the general declarative points-to analysis approach of the Doop framework and then present some recent developments. The main emphasis will be on a defensive may-point-to analysis approach, which offers soundness even in the presence of arbitrary opaque code (e.g., reflection, dynamic loading, native code). It may be surprising that this goal is even achievable, so we will emphasize the unique architecture of the analysis and of its soundness guarantee.">Declarative Static Analysis and Zombies (ok, Soundness)</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>14:15 - 15:00</td>
	<td><a href="http://plrg.kaist.ac.kr/ryu"><div class="talk" style="font-weight: normal;" data-tooltip="Sukyoung Ryu is an associate professor in the School of Computing at Korea Advanced Institute of Science and Technology (KAIST).  Her research interests are in programming languages and program analysis. She is a recipient of various awards including the Google Faculty Research Award and best paper awards in conferences. She received her Ph.D. in Computer Science from KAIST, worked at Harvard University and Sun Microsystems Laboratories.">Sukyoung Ryu</div></a></td>
	<td>KAIST, Korea</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="We present novel attacks and security vulnerabilities exploiting the weak semantics of Solidity.  We describe which semantics of Solidity enables the attacks, how we make the attacks, and concrete case samples of the attacks.  These attacks are powerful enough to pollute the values in persistent storage and to change control flows of smart contracts. Our evaluation with more than 22,000 Solidity contracts from Etherscan shows that the attacks are practically applicable to real-world smart contracts. Our manual investigation also confirms that 27.75% of our dataset indeed contain security vulnerabilities.  We are currently disclosing these vulnerable semantics of Solidity to Ethereum.">Vulnerable Semantics of Solidity</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>15:00 - 15:30</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>15:30- 16:15</td>
	<td><a href="https://www.microsoft.com/en-us/research/people/chrishaw/"><div class="talk" style="font-weight: normal;" data-tooltip="Chris Hawblitzel is a Senior Researcher at Microsoft Research.  His research focuses on using programming language techniques and formal verification to enforce the safety and security of systems software.  He has worked on projects like the Singularity OS, the Verve verified OS, the Ironclad/IronFleet verified software stack, and the Everest verified TLS project.  He received a Ph.D. in Computer Science from Cornell in 2000, and taught at Dartmouth College until 2004.">Chris Hawblitzel</div></a></td>
	<td>Microsoft Research</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="High-performance systems software often contains assembly language code.  It's easy to make mistakes when writing or modifying assembly language code, so formal verification can help ensure the security and reliability of systems containing hand-written assembly language.  This talk will present work on Vale -- Verified Assembly Language for Everest.  Vale provides a Hoare logic for assembly language, allowing programmers to annotate x86, x64, and ARM code with preconditions and postconditions used to verify the functional correctness of the code.  Vale builds on existing automated tools like Dafny, F*, and Z3 to specify correctness and verify code.  Programmers specify semantics for assembly language instructions in Dafny or F*; verification conditions are checked using the Z3 SMT solver.  As part of the Everest and HACL* projects to verify TLS and cryptographic implementations, Vale has been used to verify high-performance assembly language code for SHA, AES, and Poly1305.">Verifying assembly language with Vale</div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>16:15 - 17:00</td>
	<td><a href="https://www.cs.cmu.edu/~mfredrik/">Matt Fredrikson</a></td>
	<td>CMU, USA</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>17:00 - 17:10</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td>Closing Remarks</td>
	<td></td>
	<td></td>
</tr>


</table>

<h2 id="registration">Registration</h2>


<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=33%></th>
<th width="33%">Early Bird: by Sept 21st 2018</th>
<th width="34%">Regular fee: after Sept 21st 2018</th>

<tr>
	<td>Workshop Fee (Students)</td>
	<td>70 CHF</td>
	<td>90 CHF</td>
</tr>

<tr>
	<td>Workshop Fee (Regular)</td>
	<td>110 CHF</td>
	<td>130 CHF</td>
</tr>
</table>

The registration fees include:
<ul>
<li> Attendance to all presentations</li>
<li> Lunches on both days </li>
<li> Coffee & Snacks </li>
</ul>
<p>
To register, please follow this link: <a href="https://www.converia.ethz.ch/frontend/index.php?sub=70">Workshop Registration</a>
</br>
For information and questions, please contact Mrs. Marlies Weissert: <a href="mailto:marlies.weissert@inf.ethz.ch">marlies.weissert@inf.ethz.ch</a>.
<p>


<h2 id="travel">Travel</h2>
<p>
ETH Z&uumlrich is located in the heart of the city and easy to reach.
</br>
From <strong>Z&uumlrich HB </strong> (main station): If you arrive by train to Z&uumlrich HB, take either:
<ul>
	<li> Tram no. 6 (direction Zoo) from tram stop "Bahnhofstrasse/HB", exit at tram stop "ETH/Universit&aumltsspital" (right next to the ETH main building). Journey time: about 8 minutes or </li>
	<li> Tram no. 10 (direction Flughafen or Bahnhof Oerlikon) from tram stop "Bahnhofplatz/HB", exit at tram stop "ETH/Universit&aumltsspital". Journey time: about 8 minutes </li>
</ul>
</p>

<p>
From <a href="http://www.flughafen-zuerich.ch/"><strong>Z&uumlrich airport</strong></a>: You can either take the tram to ETH or a train to the city center (Z&uumlrich HB):
<ul>
	<li> Tram no. 10 (direction Bahnhofplatz/HB) to tram stop "ETH/Universittsspital". The tram operates daily from 6 a.m to 11 p.m. with trams departing every 7 to 15 minutes. Journey time: 30 minutes </li>
	<li> S-Bahn/Train: Follow the signs "Bahn/Railway" to the ticket counters and/or ticket machines. You will find instructions in English on the ticket machines. Get a ticket for "Z&uumlrich City" (make sure that the display shows "1 Std"). The machines accept coins as well as bills and gives change (the ticket costs 6.40 CHF). The ticket is valid for 1 hour for all trains to Z&uumlrich as well as for trams and buses in the city (streetcar, Strassenbahn). Take the escalator down to the platforms. Trains to the city center leave approx. every 10 minutes and it takes about 10 minutes to reach the main station.</li>
</ul>
</p>


<h2 id="accomodation">Accomodation</h2>
You can check the availability and prices and make reservations for hotels at <a href="http://www.zuerich.com/en/Visitor.html">Z&uumlrich Tourism</a>

<p>
The following is a list of hotels in walking distance from the workshop venue:
<ul>
	<li> <a href="http://www.hotelrex.ch/de/home.asp">Hotel Rex </a> (single room from CHF 150 to CHF 225) </li>
	<li> <a href="http://www.hotelbristol.ch/">Hotel Bristol </a> (single room from CHF 150 to CHF 200) </li>

	<li> <a href="http://www.hotelbasilea.ch">Hotel Basilea </a> (single room from CHF 195 to CHF 225) </li>
	<li> <a href="http://hotelrigihof.hotelszurich.it">Leonardo Hotel Rigihof </a>(single room from CHF 240 to CHF 290) </li>
</ul>
</p>

<p>
Some hotels further away:
<ul>
	<li> <a href="http://www.ibishotel.com/de/hotel-2942-ibis-zurich-city-west/index.shtml">Hotel Ibis Zurich City West </a> (room rate CHF 129 to CHF 164) </li>
	<li> <a href=" http://ibisbudgethotel.ibis.com/de/hotel-3184-ibis-budget-zurich-city-west/index.shtml">Hotel Ibis Budget </a> (room rate CHF 85 to CHF 99) </li>
</ul>
</p>
</div>




