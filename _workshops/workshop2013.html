---
title: Workshop on Software Correctness and Reliability
ref: workshop2013
redirect_from: workshop2013.php
bgimage: /assets/images/eth-zurich-workshop.jpg
image:
dates: Oct 4-5, 2013
place: ETH Zürich
venue: Alumni Pavillon, Rämlmistrasse 101
---



{% comment %}
		<li><a href="#workshop">Home</a></li>
		<li><a href="#schedule">Schedule</a></li>
		<li><a href="#registration">Registration</a></li>
		<li><a href="#travel">Travel</a></li>
		<li><a href="#accomodation">Accomodation</a></li>
<script type='text/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.js'></script>
<script src="https://www.sri.inf.ethz.ch/js/jquery.scrollTo-1.4.3.1-min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/tooltipsy.min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/global.js" type="text/javascript"></script>
{%endcomment%}


<h2>Workshop Information</h2>
Ensuring that our programs behave correctly and reliably is a fundamental challenge facing computing today. Recent years have seen an explosion of a diverse set of new techniques for ensuring program correctness ranging from verification and synthesis approaches to runtime systems to quantitative reasoning. The aim of the workshop is to provide insight into the latest research advances in the area. In a period of two days, the workshop will host a number of invited speakers who will present research talks related to software reliability and correctness.

<h2>Organizers</h2>
<p>
<a href="http://www.pm.inf.ethz.ch/people/personal/pmueller-pers.html">Peter M&uumlller (ETH Z&uumlrich) </a>, <a href="{{ "/people/martin" | relative_url }}">Martin Vechev (ETH Z&uumlrich) </a>
</p>


<h2 id="schedule">Schedule</h2>
<h3>October 4 (Friday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=17%>Time</th><th width="16%">Speaker</th><th width="22%">Institution</th><th width=33%>Talk Title & Abstract</th><th width=8%>Slides</th><th width=4%>Video</th>



<tr>
	<td>9:00  - 9:15</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Introduction of participants. Workshop objectives.">Opening Remarks</div></td>
	<td>first 3.40 min</td>
	<td><a href="http://www.youtube.com/watch?v=Ayg0V1qiJwc&noredirect=1" title="eth-intro"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>9:15 - 10:00</td>
	<td><a href="http://www.cs.rice.edu/~vardi/">Moshe Vardi</a></td><td>Rice University</td><td><div class="talk" data-tooltip="One of the surprising developments in the area of program verification in the late part of the 20th Century is the emergence of Linear Temporal Logic (LTL), a logic that emerged in philisophical studies of free will, as the cannonical language for describing temporal behavior of computer systems. LTL, however, is not expressive enough for industrial applications. The first decade of the 21 Century saw the emergence of industrial temporal logics such as ForSpec, PSL, and SVA. These logics, however, are not clean enough to serve as objects of theoretical study. This talk will describe the rise and fall of LTL, and will propose a new cannonical temporal logic: Linear Dynamic Logic (LDL).">The Rise and Fall of <br> Linear Temporal Logic</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-vardi.pdf" | relative_url }}" class="pdf" title="eth-vardi"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=Ayg0V1qiJwc&noredirect=1" title="eth-vardi"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>10:00 - 10:45</td>
	<td><a href="http://researcher.watson.ibm.com/researcher/view.php?person=us-bacon">David Bacon</a></td>
	<td>IBM T.J. Watson <br> Research Center</td>
	<td><div class="talk" data-tooltip="Software construction has typically drawn on engineering metaphors like building bridges or cathedrals, which emphasize architecture, specification, central planning, and determinism. On the other hand, formal approaches to correctness have drawn on metaphors from mathematics, like proofs. However, both of these approaches have failed to scale to modern software systems, and the problem keeps getting worse.

	We believe that the time has come to completely re-imagine the creation of complex software, drawing on systems in which behavior is decentralized, self-regulating, non-deterministic, and emergent---like economies. In this talk I will describe our vision for, and prelimary work on, the creation of software economies for both open systems and internal corporate development, and describe various systems already existing that provide some of the components from which such economies could be assembled.

	Joint work with Yiling Chen, Ian Kash, David Parkes, Malvika Rao (Harvard), Erik Bokelberg and Manu Sridharan (IBM).">Economic Approaches to <br> Software Correctness</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-bacon.pdf" | relative_url }}" class="pdf" title="eth-bacon"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=DDcMl_VdBmM" title="eth-bacon"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>10:45 - 11:15</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>11:15 - 12:00</td>
	<td><a href="http://www.cs.tau.ac.il/~msagiv/">Mooly Sagiv</a></td>
	<td>Tel Aviv University</td><td><div class="talk" data-tooltip="First order logic with transitive closure, and separation logic enable elegant interactive verification of heap-manipulating programs. However, undecidabilty results and high asymptotic complexity of checking validity preclude complete automatic verification of such programs, even when loop invariants and procedure contracts are specified as formulas in these logics.

	This work tackles the problem of procedure-modular verification of reachability properties of heap-manipulating programs using efficient decision procedures that are complete: that is, a SAT solver must generate a counterexample whenever a program does not satisfy its specification. By (a) requiring each procedure modifies a fixed set of heap partitions and creates a bounded amount of heap sharing, and (b) restricting program contracts and loop invariants to use only deterministic paths in the heap, we show that heap reachability updates can be described in a simple manner. The restrictions force program specifications and verification conditions to lie within a fragment of first-order logic with transitive closure that is reducible to effectively propositional logic, and hence facilitate sound, complete and efficient verification.

	We implemented a tool atop Z3 and report on preliminary experiments that establish the correctness of several programs that manipulate trees and linked lists.

	This is a joint work with Shachar Itzhaky and Ori Lahav (Tel Aviv University), Neil Immerman from (UMASS), Anindya Benerjee and Aleksandar Nanevski (IMDEA)">Modular Reasoning about Heap Paths via Effectively Propositional Formulas</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-sagiv.pdf" | relative_url }}" class="pdf" title="eth-sagiv"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=fN2JWDDf5fg" title="eth-sagiv"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>12:00 - 13:30</td>
	<td></td>
	<td colspan=2>Lunch</td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>13:30 - 14:15</td>
	<td><a href="http://www.cs.uwm.edu/~boyland/"> John Boyland</a></td>
	<td>University of <br> Wisconsin, <br> Milwaukee</td>
	<td><div class="talk" data-tooltip="Concurrent type systems are systems of rules for how to write programs so that they will behave correctly with respect to the concurrent or parallel memory model when executed. Of course the mere existence of rules does not ensure that the model is being used properly.  Thus the concurrent type system should be proved correct.  Such proofs are long and complex.  It is desirable to reuse existing proofs where possible (whether mechanized or not).

	Two possibilities where one can connect with an existing system are at the 'fractional permission' level, and at the 'write key' level. The latter and lower level explains the proper use of locks and 'volatile' fields through the use of 'ghost' state tracking who has seen the most recent write of a field.  The former and higher level describes what state can be accessed using linear and fractional permissions and non-linear nesting facts.  The talk gives examples of using each level for proof re-use.  It then compares these approaches with similiarly motivated systems.">Two Levels of Reuse for Proving Correctness of Concurrent Type Systems</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-boyland.pdf" | relative_url }}" class="pdf" title="eth-boyland"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=9XC6sFK5edU" title="eth-boyland"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>14:15 - 15:00</td>
	<td><a href="http://www7.in.tum.de/~rybal/">Andrey Rybalchenko</a></td>
	<td>Microsoft Research,<br>TU Munich</td>
	<td><div class="talk" data-tooltip="Quantified Horn clauses can be used to represent proof obligations for a variety of verification and synthesis tasks, e.g., proving existential temporal properties, solving games, and dealing with container data structures. We discuss application scenarios for quantified Horn clauses and briefly overview solving approaches, as well as experience with extending our solver ARMC to support quantification.

	Joint work with Tewodros Beyene, Nikolaj Bjorner, Swarat Chaudhuri, Ken McMillan, and Corneliu Popeea.  ">Solving Quantified Horn Clauses</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-rybalchenko.pdf" | relative_url }}" class="pdf" title="eth-rybalchenko"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="https://www.youtube.com/watch?v=bTPSCVzp1m8" title="eth-rybalchenko"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>


<tr>
	<td>15:00 - 15:30</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>15:30 - 16:15</td>
	<td><a href="http://www.cs.purdue.edu/homes/jv/">Jan Vitek</a></td>
	<td>Purdue University</td>
	<td><div class="talk" data-tooltip="Formal approaches to program correctness through static software verification have influenced the design of programming languages, programming models, and developer tools for the last fifty years. Yet static techniques can only handle a small fraction of the programs written in the languages they claim to target. By and large academic research in the field has been about analyzing languages that all look and feel like Pascal; languages with a static type discipline and with read-only programs. This has very little to do with popular languages in use today. Languages like JavaScript, Python, Lua and R where typing is dynamic and new behaviors can be synthesized at runtime through powerful reflective programming interfaces. Instead of embracing dynamism and trying to support popular programming idioms, our community keeps proposing solutions that impose static disciplines on programmers. We keep trying to find the inner Pascal in every JavaScript. This is bound to drive practitioners away and ensure our continued irrelevance. Are we bound to repeat history or is there a way out? ">Why JavaScript Programmers Hate You: an ode to dynamic languages</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-vitek.pdf" | relative_url }}" class="pdf" title="eth-vitek"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=t3GzCwoQfb4" title="eth-vitek"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>16:15 - 16:45</td>
	<td><a href="{{ "/people/martin" | relative_url }}">Martin Vechev</a><br></td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Like shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug. Yet, these races may cause serious damage (e.g. JavaScript crashes, lost e-mails, broken UI).

	Building a concurrency detector which can find harmful races in this setting is particularly challenging due to: i) heavy use of ad-hoc synchronization leading to an overwhelming number of false positives, ii) complex interaction between a large number of events which can render current analyzers impractical, and iii) a need to precisely capture the happens-before relation which is assembled from a diverse set of sources.

	In this talk, I will present EventRacer, a dynamic race detector that addresses these challenges and finds real bugs in web applications. We focus on the key points that  made EventRaces possible.

	We first present a scalable algorithm that uses graph connectivity based on chain-decomposition to find races in long executions. This algorithm significantly outperforms existing state-of-the-art detectors, in both space and time.

	We then define and show how to find uncovered races -- a special class of races that are not affected by user-written ad-hoc synchronization. Uncovered races are key to reducing the number of false positives reported by the tool.

	We finally present an evaluation of our approach on a set of widely used websites, demonstrate that harmful races are widespread, and show how they could negatively affect user experience.

	The full source, binary distributions and an online interface are available here: http://www.eventracer.org/

	joint work with Veselin Raychev (ETH) and Manu Sridharan (IBM T.J. Watson Research Center)">Race Detection for <br> Event Driven Apps</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-vechev.pdf" | relative_url }}" class="pdf" title="eth-vechev"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=NolhAtT65G4" title="eth-vechev"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>16:45 - 17:15</td>
	<td><a href="http://www.pm.inf.ethz.ch/people/pmueller">Peter M&uumlller </a></td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Many mainstream static program checkers sacrifice soundness to increase automation, improve performance, and reduce both the number of false alarms and the annotation overhead for the programmer. Typical sources of unsoundness in such checkers are not checking certain program properties and making implicit, unsound assumptions. As a result, static checkers that make such compromises cannot provide definite guarantees about program correctness, thus rendering unclear which properties remain to be tested. To address this problem, we present a technique that: (1) makes the compromises of static checkers explicit and their verification results precise with a simple language extension, (2) facilitates collaborative verification, that is, the integration of multiple, complementary static checkers, and (3) reinforces static checking with automatic test case generation to compensate for any soundness limitations of the static checkers.">Collaborative Verification and Testing</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-mueller.pdf" | relative_url }}" class="pdf" title="eth-mueller"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=-8ntH6zyTfY" title="eth-mueller"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>
</table>

<h3>October 5 (Saturday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=17%>Time</th>
<th width="16%">Speaker</th>
<th width="22%">Institution</th>
<th width=33%>Talk Title & Abstract</th>
<th width=8%>Slides</th>
<th width=4%>Video</th>

<tr>
	<td>9:00  - 9:15</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td><div class="talk" data-tooltip="Introduction to second day.">Opening Remarks </div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>9:15 - 10:00</td>
	<td><a href="http://research.microsoft.com/en-us/people/bycook/">Byron Cook</a></td>
	<td>Microsoft Research, UCL</td>
	<td><div class="talk" data-tooltip="So we can prove program termination. Now what? In this talk I will discuss the development of tools that build on termination proving techniques.">Beyond Termination</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-cook.pdf" | relative_url }}" class="pdf" title="eth-cook"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=_LqXVnq_rWM" title="eth-cook"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>10:00 - 10:45</td>
	<td><a href="http://www.cs.columbia.edu/~junfeng/">Junfeng Yang</a></td>
	<td>Columbia University</td>
	<td><div class="talk" data-tooltip="Our accelerating computational demand and the rise of multicore hardware have made parallel programs, especially shared-memory multithreaded programs, increasingly pervasive and critical. Yet, these programs remain extremely difficult to write, test, analyze, debug, and verify. Conventional wisdom has attributed these difculties to nondeterminism (i.e., repeated executions of the same program on the same input may show different behaviors), and researchers have recently dedicated much effort to bringing determinism into multithreading. In this talk, I argue that determinism is not as useful as commonly perceived: it is neither sufficient nor necessary for reliability. We present our view on why multithreaded programs are difficult to get right, describe a promising approach we call stable multithreading to dramatically improve reliability, and summarize our last four years of research on building and applying stable multithreading systems.

	More details are at http://www.cs.columbia.edu/~junfeng/.">Stabilization in Concurrent Programming</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-yang.pdf" | relative_url }}" class="pdf" title="eth-yang"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=m04-_C9fXoQ" title="eth-yang"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>10:45 - 11:15</td>
	<td></td>
	<td>Coffee Break</td>
	<td></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>11:15 - 12:00</td>
	<td><a href="http://lara.epfl.ch/~kuncak">Viktor Kuncak</a></td>
	<td>EPFL</td>
	<td><div class="talk" data-tooltip="Specifications are key to improving software reliability as well as documenting precisely the intended behavior of software. Writing specifications is still perceived as expensive. Of course, writing implementations is at least as expensive, but is hardly questioned because there is currently no real alternative. Our goal is to give specifications a more balanced role compared to implementations, enabling the developers to compile, execute, optimize, and verify against each other mixed code fragments containing both specifications and implementations. To make specification constructs executable we combine deductive synthesis with run-time constraint solving, in both cases leveraging modern SMT solvers. Our tool decomposes specifications into simpler fragments using a cost-driven deductive synthesis framework.  It compiles as many fragments as possible into conventional functional code; it executes the remaining fragments by invoking our constraint solver that extends an SMT solver to handle recursive functions.  Using this approach we were able to execute constraints that describe the desired properties of integers, sets, maps and algebraic data types.">Executing Specifications using Synthesis and Constraint Solving</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-kuncak.pdf" | relative_url }}" class="pdf" title="eth-kuncak"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=EA4TY47ihzg" title="eth-kuncak"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>12:00 - 13:30</td>
	<td></td>
	<td colspan=2>Lunch</td>
	<td></td>
	<td></td>
</tr>


<tr>
	<td>13:30 - 14:15</td>
	<td><a href="http://www.cs.technion.ac.il/~yahave/">Eran Yahav</a></td>
	<td>Technion</td>
	<td><div class="talk" data-tooltip="We present a framework for data-driven synthesis, aiming to leverage the collective programming knowledge captured in millions of open-source projects. Our framework analyzes code snippets and extracts partial temporal specifications. Technically, partial temporal specications are represented as symbolic automata where transitions may be labeled by variables, and a variable can be substituted by a letter, a word, or a regular language. Using symbolic automata, we consolidate separate examples to create a database of snippets that can be used for semantic code-search and component synthesis.  We have implemented our approach in a tool called PRIME and applied it to analyze and consolidate thousands of snippets per tested API.

	This talk is based on work with Hila Peleg, Alon Mishne,Sharon Shoham, and Hongseok Yang.">Programming with <br> Millions of Examples</div></td>
	<td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2013/eth-yahav.pdf" | relative_url }}" class="pdf" title="eth-yahav"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="http://www.youtube.com/watch?v=hCxKD1u2C40" title="eth-yahav"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>


<tr>
	<td>14:15 - 15:00</td>
	<td><a href="">Ernie Cohen</a></td>
	<td></td>
	<td><div class="talk" data-tooltip="Concurrent programming (particularly verified concurrent programming) is usually based on sequentially consistent (SC) memory, provided either through the platform or through a programming discipline, because programming to weaker memory models is considered too difficult. It turns out that this isnt the case; from the perspective of program reasoning, C11/C++11 acquire-release programming is no harder than SC programming; the only difference is in the rules for updating ghost state.">Assertional reasoning for weak memory</div></td>
	<td>Speaker used blackboard</td>
	<td><a href="http://www.youtube.com/watch?v=vmnKPXKl408" title="eth-cohen"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>


<tr>
	<td>15:00 - 15:10</td>
	<td>Organizers</td>
	<td>ETH Z&uumlrich</td>
	<td>Closing Remarks</td>
	<td>Last 10 sec</td>
	<td><a href="http://www.youtube.com/watch?v=vmnKPXKl408" title="eth-closing"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>


</table>

<h2 id="registration">Registration</h2>


<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=33%></th>
<th width="33%">Early Bird: by Sept 1st 2013</th>
<th width="34%">Regular fee: after Sept 1st 2013 (latest day: Sept 26, 2013)</th>

<tr>
	<td>Workshop Fee (Students)</td>
	<td>60 CHF</td>
	<td>80 CHF</td>
</tr>

<tr>
	<td>Workshop Fee (Regular)</td>
	<td>100 CHF</td>
	<td>120 CHF</td>
</tr>
</table>

The registration fees include:
<ul>
<li> Attendance to all presentations</li>
<li> Lunches on both days </li>
<li> Coffee & Snacks </li>
</ul>
<p>
To register, please follow this link: <a href="http://www.idbd.evento.ethz.ch/dispatch.asp?fct=AnmeldungEdit&IdAnlass=1330">Workshop Registration</a></p>

<p>
For information and questions, please contact Mrs. Marlies Weissert: marlies.weissert@inf.ethz.ch
</p>


<h2 id="travel">Travel</h2>
<p>
ETH Z&uumlrich is located in the heart of the city and easy to reach.
</br>
From <strong>Z&uumlrich HB</strong> (main station): If you arrive by train to Z&uumlrich HB, take either:
<ul>
	<li> Tram no. 6 (direction Zoo) from tram stop "Bahnhofstrasse/HB", exit at tram stop "ETH/Universit&aumltsspital" (right next to the ETH main building). Journey time: about 8 minutes or </li>
	<li> Tram no. 10 (direction Flughafen or Bahnhof Oerlikon) from tram stop "Bahnhofplatz/HB", exit at tram stop "ETH/Universit&aumltsspital". Journey time: about 8 minutes </li>
</ul>
</p>

<p>
From <a href="http://www.flughafen-zuerich.ch/"><strong>Z&uumlrich airport</strong></a>: You can either take the tram to ETH or a train to the city center (Z&uumlrich HB):
<ul>
	<li> Tram no. 10 (direction Bahnhofplatz/HB) to tram stop "ETH/Universittsspital". The tram operates daily from 6 a.m to 11 p.m. with trams departing every 7 to 15 minutes. Journey time: 30 minutes </li>
	<li> S-Bahn/Train: Follow the signs "Bahn/Railway" to the ticket counters and/or ticket machines. You will find instructions in English on the ticket machines. Get a ticket for "Z&uumlrich City" (make sure that the display shows "1 Std"). The machines accept coins as well as bills and gives change (the ticket costs 6.40 CHF). The ticket is valid for 1 hour for all trains to Z&uumlrich as well as for trams and buses in the city (streetcar, Strassenbahn). Take the escalator down to the platforms. Trains to the city center leave approx. every 10 minutes and it takes about 10 minutes to reach the main station.</li>
</ul>
</p>


<h2 id="accomodation">Accomodation</h2>
You can check the availability and prices and make reservations for hotels at <a href="http://www.zuerich.com/en/Visitor.html">Z&uumlrich Tourism</a>

<p>
The following is a list of hotels in walking distance from the workshop venue:
<ul>
	<li> <a href="http://www.hotelrex.ch/de/home.asp">Hotel Rex </a> (single room from CHF 150 to CHF 225) </li>
	<li> <a href="http://www.hotelbristol.ch/">Hotel Bristol </a> (single room from CHF 150 to CHF 200) </li>

	<li> <a href="http://www.hotelbasilea.ch">Hotel Basilea </a> (single room from CHF 195 to CHF 225) </li>
	<li> <a href="http://hotelrigihof.hotelszurich.it">Leonardo Hotel Rigihof </a>(single room from CHF 240 to CHF 290) </li>
</ul>
</p>

<p>
Some hotels further away:
<ul>
	<li> <a href="http://www.ibishotel.com/de/hotel-2942-ibis-zurich-city-west/index.shtml">Hotel Ibis Zurich City West </a> (room rate CHF 129 to CHF 164) </li>
	<li> <a href=" http://ibisbudgethotel.ibis.com/de/hotel-3184-ibis-budget-zurich-city-west/index.shtml">Hotel Ibis Budget </a> (room rate CHF 85 to CHF 99) </li>
</ul>
</p>
</div>




