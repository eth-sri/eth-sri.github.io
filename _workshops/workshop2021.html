---
title: Workshop on Dependable and Secure Software Systems
ref: workshop2021
redirect_from: workshop2021.php
bgimage: /assets/images/eth-zurich-workshop.jpg
image: /assets/images/workshop2021.png
dates: Oct 25-26, 2021
place: ETH Zurich
venue: online
---



{% comment %}
		<li><a href="#workshop">Home</a></li>
		<li><a href="#schedule">Schedule</a></li>
		<li><a href="#registration">Registration</a></li>
		<li><a href="#travel">Travel</a></li>
		<li><a href="#accomodation">Accomodation</a></li>
<script type='text/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.js'></script>
<script src="https://www.sri.inf.ethz.ch/js/jquery.scrollTo-1.4.3.1-min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/tooltipsy.min.js" type="text/javascript"></script>
<script src="https://www.sri.inf.ethz.ch/js/global.js" type="text/javascript"></script>
{%endcomment%}

<h2>Workshop Information</h2>
Ensuring that our programs behave securely and reliably is a fundamental challenge facing computing today. Recent years have seen an explosion of a diverse set of new techniques for addressing this challenge ranging from verification and synthesis approaches to dynamic methods to quantitative reasoning to machine learning techniques. The aim of the workshop is to provide insight into the latest research advances in the area by hosting leading scientists who will present the latest and most advanced methods for addressing this fundamental challenge.

<h2>Organizers</h2>
<p>
<a href="http://www.pm.inf.ethz.ch/people/personal/pmueller-pers.html">Peter M&uumlller (ETH Zurich) </a>, <a href="https://acl.inf.ethz.ch/people/markusp/">Markus Püschel (ETH Zurich)</a>, <a href="https://ast.ethz.ch/the-group/group-members.html">Zhendong Su (ETH Zurich)</a>, <a href="{{ "/people/martin" | relative_url }}">Martin Vechev (ETH Zurich) </a>
</br>
</br>
This is the eight time the workshop is being held (formerly Workshop on Software Correctness and Reliability). Materials from the
<a href="{{ "/workshop2019" | relative_url }}">2019</a>,
<a href="{{ "/workshop2018" | relative_url }}">2018</a>,
<a href="{{ "/workshop2017" | relative_url }}">2017</a>,
<a href="{{ "/workshop2016" | relative_url }}">2016</a>,
<a href="{{ "/workshop2015" | relative_url }}">2015</a>,
<a href="{{ "/workshop2014" | relative_url }}">2014</a> and
<a href="{{ "/workshop2013" | relative_url }}">2013</a> workshops are also available.
</p>

<h2 id="schedule">Schedule</h2>

<h3>October 25 (Monday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=20%>Time</th>
<th width="25%">Speaker</th>
<th width="20%">Institution</th>
<th width=23%>Talk Title & Abstract</th>
<th width=8%>Slides</th>
<th width=4%>Video</th>

<tr>
	<td>5:00pm - 5:15pm</td>
	<td>Organizers</td>
	<td>ETH Zurich</td>
	<td><div class="talk" data-tooltip="Introduction of participants. Workshop objectives.">Opening Remarks </div></td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>5:15pm - 6:00pm</td>
    <td><a href=" http://people.mpi-sws.org/~dg/"><div class="talk" style="font-weight: normal;" >Deepak Garg</div></a></td>
    <td>MPI-SWS</td>
    <td><div class="talk" style="color: #0079AF;" data-tooltip="The following compilation situation arises often. A developer writes a program module M in a source language and reasons (formally or informally) that M is secure against attacks from any co-linked modules in the source language. However, to run the module M, the developer compiles it to a target language, and links the compiled program to semi-trusted libraries written in the target language to obtain an executable. Clearly there is a mismatch here: The developer reasons about the module M's security against source language modules, but actually runs M against target language modules, which may be much more powerful, e.g., target language modules may be able to perform low-level control-flow hijacking or buffer overflow attacks that may be completely impossible in the source language semantics. "> Proving compiler security with dynamic memory sharing and proof reuse</div></td>
    <td></td>
	  <td></td>
</tr>

<tr>
	<td>6:00pm - 6:45pm</td>
  <td><a href="https://dslab.epfl.ch/people/candea/"><div class="talk" style="font-weight: normal;" data-tooltip=" George Candea heads the Dependable Systems Lab at EPFL, where he conducts research on both the fundamentals and the practice of building dependable computer systems. His main focus is on real-world systems software, because going from a small program to a large system introduces fundamental challenges that cannot be addressed with the techniques that work at small scale. In the past, George co-founded Cyberhaven, a cybersecurity company now based in Palo Alto, Lausanne and Kiev, which he led as its first CEO and then Chief Scientist. Previously, he co-founded Aster Data Systems (now Teradata Vantage), one of the first big-data companies in Silicon Valley, where he served as CTO and then Chief Scientist. Before that, he held positions at Oracle, Microsoft Research, and IBM Research. George is a recipient of the first Eurosys Jochen Liedtke Award (2014), an ERC award (2011), and the MIT TR35 award (2005). He received his PhD (2005) in computer science from Stanford and his B.S. (1997) and M.Eng. (1998) in electrical engineering and computer science from MIT. "> George Candea</div></a></td>
  <td>EPFL</td>
  <td><div class="talk" style="color: #0079AF;" data-tooltip="Modern programmers routinely use third-party code, and cloud operators deploy software they did not write. This would not be possible without semantic interfaces, i.e., header files/abstract classes/documentation that succinctly describe what that third-party code does. In this talk I will explore the possibility of having similarly developer-friendly, productivity-enhancing performance interfaces –- succinct descriptions of how systems code performs under all relevant conditions. What should such an interface look like? How can we use such an interface? How can we verify formally the compliance with such an interface? Can such interfaces be automatically extracted from systems code? I will describe our initial work on this, with some interesting use cases and promising results in the field of networking, and then I hope to have a discussion on how these ideas generalize to other kinds of systems software."> Performance Interfaces for Systems Code </div></td>
  <td></td>
	<td></td>
</tr>

<tr>
	<td>6:45pm - 7:00pm</td>
	<td></td>
	<td colspan=2>Break</td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>7:00pm - 7:45pm</td>
  <td><a href=" https://xnning.github.io/"><div class="talk" style="font-weight: normal;" data-tooltip="Ningning Xie is a research associate at University of Cambridge. She received her Ph.D. in Computer Science at the University of Hong Kong. Her research interests are in the field of programming languages, focusing on functional programming and type theory. During her Ph.D. study, Ningning was a research intern at Microsoft Research Redmond and DeepMind London. She is a recipient of the ACM SIGPLAN Distinguished Paper Award at the Symposium on Principles of Programming Languages (POPL 2020) as well as the Conference on Programming Language Design and Implementation (PLDI 2021), and was selected for Rising Stars 2020 organized by UC Berkeley."> Ningning Xie</div></a></td>
	<td>University of Cambridge</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Real-world programs come with side effects and complex control flows. How to compose different computational effects? How to handle effects differently according to applications? Algebraic effects and handlers provide a powerful and flexible way to add structured computational effects to programming languages. Unfortunately, it is not straightforward to compile effect handlers into efficient code: effect operations are generally able to capture- and resume a delimited continuation, which usually requires special runtime support to do efficiently. In this talk, I will present efficient compilation techniques for algebraic effect handlers as implemented in the Koka programming language, a function-oriented language with effect inference which is being actively developed at Microsoft Research."> Efficient Compilation of Algebraic Effect Handlers</div></td>
  <td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2021/Ningning_Xie.pdf" | relative_url }}" class="pdf" title="slides Ningning Xie"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href=" https://youtu.be/tWLPrPfb4_U " title="Ningning Xie"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>7:45pm - 8:30pm</td>
	<td><a href="http://justingottschlich.com/" style="font-weight: normal;" data-tooltip="Justin Gottschlich is a Principal AI Scientist and the Founder & Director of Machine Programming Research at Intel Labs. He also has an academic appointment as an Adjunct Assistant Professor at the University of Pennsylvania. Justin is the Principal Investigator of the upcoming Intel Machine Programming Research Center, which will focus on the automation of software development. He co-founded the ACM SIGPLAN Machine Programming Symposium (MAPS) and serves as its Steering Committee Chair. He is currently serving on two technical advisory boards: the 2020 NSF Expeditions “Understanding the World Through Code” led by MIT Prof. Armando Solar-Lezama and Inteon, a new machine programming (MP) venture wholly funded by Intel. Justin received his PhD in Computer Engineering from the University of Colorado-Boulder in 2011 and has 40+ peer-reviewed publications, ~50 issued patents, with 100+ patents pending. Justin and his team’s research have been highlighted in venues like Communications of the ACM, MIT Technology Review, The New York Times, and The Wall Street Journal."> Justin Gottschlich</div></a></td>
	<td>Intel</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="In this talk, we discuss machine programming (MP), which is principally aimed at the automation of software development. We discuss how our research team at Intel Labs, Machine Programming Research, is working toward new ways to automatically develop software based on two key tenets: (i) improving software developer productivity and (ii) improving software quality (e.g., correctness, performance, security, etc.). We discuss MP across three pillars: intention, invention, and adaptation. We also discuss the criticality of data for dependable and secure MP systems, which we believe is foundational to all MP systems. We close with some recent MP systems that we have built that have demonstrated state-of-the-art performance in code semantics similarity, security debugging, and optimization."> Machine Programming & Data-Driven Dependable and Secure Software Systems</div></td>
  <td></td>
	<td><a href=" https://youtu.be/0wU-ZQnGLBw" title="Justin Gottschlich"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>8:30pm - 8:40pm</td>
	<td>Organizers</td>
	<td>ETH Zurich</td>
	<td>Closing Remarks</td>
	<td></td>
	<td></td>
</tr>
  
</table>

<h3>October 26 (Tuesday)</h3>
<table centering border="0" width="100%" cellspacing="0" cellpadding="0">

<th width=20%>Time</th>
<th width="25%">Speaker</th>
<th width="20%">Institution</th>
<th width=23%>Talk Title & Abstract</th>
<th width=8%>Slides</th>
<th width=4%>Video</th>

<tr>
	<td>5:00pm  - 5:15pm</td>
	<td>Organizers</td>
	<td>ETH Zurich</td>
	<td><div class="talk" data-tooltip="Introduction to second evening.">Opening Remarks </div></td>
	<td></td>
	<td></td>
</tr>

  
<tr>
	<td>5:15pm - 6:00pm</td>
    <td><a href="https://aws.amazon.com/security/provable-security/"><div class="talk" style="font-weight: normal;" data-tooltip=" Byron Cook is a world-renowned leader in the field of formal verification. For over 20 years Byron has worked to bring this field from academic hypothesis to mechanised industrial reality. Byron has made major research contributions, built influential tools, led teams that operationalised formal verification activities, and helped establish connections between others that have dramatically accelerated growth of the area. Byron’s tools have been applied to a wide array of topics, e.g. biological systems, computer operating systems, programming languages, and security. Byron’s Automated Reasoning Group at Amazon is leading the field to even greater success ">Byron Cook</div></a></td>
    <td>Amazon</td>
	  <td><div class="talk" style="color: #0079AF;" data-tooltip="With only a few niche exceptions, the software industry has not yet figured out how to make deep use of formal mechanical reasoning based on mathematical logic.  At Amazon we’ve recently seen tremendous adoption of the approach by product groups, with a variety of customer-facing launches that use automated reasoning, and numerous internal proof projects.  This talk attempts to capture aspects of why Amazon has been successful where others have been less so, with the hope of finding working models that can be applied in organizations outside of Amazon."> On the Business of Proof </div></td>
    <td></td>
	  <td></td>
</tr>

<tr>
	<td>6:00pm - 6:45pm</td>
  <td><a href=" https://cseweb.ucsd.edu/~npolikarpova/"><div class="talk" style="font-weight: normal;" data-tooltip="Nadia Polikarpova is an assistant professor at UC San Diego, and a member of the Programming Systems group. She received her Ph.D. in Computer Science from ETH Zurich in 2014, and then spent a couple years as a postdoctoral researcher at MIT. Nadia's research interests are in program synthesis, program verification, and type systems. She is a 2020 Sloan Fellow, and a recipient of the 2020 NSF Career Award and the 2020 Intel Rising Stars Award.">Nadia Polikarpova</div></a></td>
	<td>UC San Diego</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Low-level pointer-manipulating programs form the backbone of our digital infrastructure. Unfortunately, they are susceptible to memory safety bugs, such as buffer overflows and use-after-free, which lead to crashes and security vulnerabilities. A promising approach to eliminating memory safety bugs is to use program synthesis technology to generate provably safe low-level code automatically from high-level specifications. In this talk I will present a program synthesizer SuSLik, which accepts a logical specification as input, and produces a provably safe C program as output. SuSLik is the first synthesizer capable of generating a wide range of operations on linked data structures (such as singly- and doubly-linked lists, sorted lists, and trees) without additional hints from the user. To make this possible, SuSLik relies on a novel proof system—synthetic separation logic—to derive correct-by-construction programs directly from their specifications."> Synthesis of Safe Pointer-Manipulating Programs</div></td>
  <td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2021/Nadia_Polikarpova.pdf" | relative_url }}" class="pdf" title="slides Nadia Polikarpova"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td><a href="https://youtu.be/SENEf-3lU1o" title="Nadia Polikarpova"><img class="svg-icon" src="{{ '/assets/icons/icon-video.svg' | relative_url }}"></a></td>
</tr>

<tr>
	<td>6:45pm - 7:00pm</td>
	<td></td>
	<td colspan=2>Break</td>
	<td></td>
	<td></td>
</tr>

<tr>
	<td>7:00pm - 7:45pm</td>
  <td><a href="https://www.cs.utexas.edu/~amiltner/"><div class="talk" style="font-weight: normal;" >Anders Miltner</div></a></td>
  <td>University of Texas at Austin</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Data structures provide safe mechanisms to maintain and organize data. But it does so at a cost: to obtain this safety, data structures necessitate representation invariants, predicates over the underlying data stores. To verify that a data structure is correct one must first identify a representation invariant. Furthermore, if one is to synthesize new functions for that data structure, one must ensure that the generated code does not break its invariants. In this talk, I will present two tools: Hanoi and Burst. Hanoi automatically generates representation invariants for a data structure, given a set of theorems about how that data structure should behave. Burst takes a logical specification as input and outputs a function satisfying that specification. This enables generating functions that are guaranteed to respect data structure invariants. Lastly, I will present some general approaches on how to use these tools for full data-structure inference."> Verification and Synthesis for Data Structures</div></td>
  <td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2021/Anders_Miltner.pdf" | relative_url }}" class="pdf" title="slides Anders Miltner"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td></td>
</tr>

<tr>
	<td>7:45pm - 8:30pm</td>
	<td><a href="https://mboehme.github.io/manifesto.html"><div class="talk" style="font-weight: normal;" data-tooltip="Marcel Böhme is a tenure-track faculty at MPI-SP and head of the Software Security research group. Previously, he was an ARC DECRA Fellow and a Senior Lecturer at Monash University in Australia and PostDoc at the CISPA Helmholtz Zentrum. Marcel received his PhD from the National University of Singapore. His current research interest is the automatic discovery of software bugs and security flaws at the very large scale. One part of his group develops the foundations of automatic software testing to elucidate fundamental limitations of existing techniques, and to explore the assurances that software testing provides when no bugs are found. The other part of his group develops practical vulnerability discovery tools that are publicly available and widely used in software security practice. Marcel is leading his group with an explicit reproducibility policy.">Marcel Böhme</div></a></td>
	<td>MPI-SP</td>
	<td><div class="talk" style="color: #0079AF;" data-tooltip="Fuzzing has become a tremendous success story for automated bug finding. For instance, Google has been fuzzing the 500 most popular open source projects on 100k+ machines 24/7. The average open-source project receives bug reports at a constant rate of three to four new bugs per week - many of which are security critical. So, what makes fuzzing so efficient? Under which conditions does a simple random test input generation outperform symbolic execution even if we assume that the latter could prove the absence of bugs? Which kind of correctness guarantees does a fuzzing campaign provide that finds no bugs? And how many more bugs does an adversary find that has 10^x times more machines than I do?"> On the Surprising Efficiency and Exponential Cost of Fuzzing</div></td>
  <td><a href="{{"https://files.sri.inf.ethz.ch/website/events/workshop2021/Marcel_Boehme.pdf" | relative_url }}" class="pdf" title="slides Marcel Böhme"><img src="{{ "/assets/icons/icon-slides.svg" | relative_url }}" class="svg-icon" border="0" alt="PDF" noborder></a></td>
	<td></td>
</tr>

<tr>
	<td>8:30pm - 8:40pm</td>
	<td>Organizers</td>
	<td>ETH Zurich</td>
	<td>Closing Remarks</td>
	<td></td>
	<td></td>
</tr>


</table>

<h2 id="registration">Registration</h2>

<table centering border="0" width="100%" cellspacing="0" cellpadding="0">
    <th width="25%">Workshop Fee</th>
    <th width=75%></th>
  
    <tr>
    	<td>Students</td>
    	<td>30 CHF</td>
    </tr>
    
    <tr>
    	<td>Regular</td>
    	<td>50 CHF</td>
    </tr>
</table>

The registration fees include:
<ul>
  <li> Online attendance to all presentations</li>
  <li> Question & answer sessions</li>
  <li> Availability of slides and videos for most presentations</li>
</ul>
<p>
To register, please follow this link: <a href="https://ethzurich.eventsair.com/wdsss2021/reg">Workshop Registration</a>. Registration will close on Tuesday, 26 October, 04:00pm (CEST, UTC +2).
</br>
For information and questions, please contact Mrs. Fiorella Meyer, ETH Zurich: <a href="mailto:fiorella.meyer@inf.ethz.ch">fiorella.meyer@inf.ethz.ch</a>.
</br>
</br>
</br>
<p>
</div>





